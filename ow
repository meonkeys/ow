#!/usr/bin/python3
# PYTHON_ARGCOMPLETE_OK

# ow - Nextcloud command-line client - main code
# Copyright (C) 2023-2024 Adam Monsen
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import configparser
from datetime import datetime, timedelta, timezone
from dateutil.parser import parse
import os
import pathlib
import re
import requests
import sys
import subprocess
import tempfile
import xml.etree.cElementTree as cET
import urllib
import inspect

nextcloudWebdavRoot = 'remote.php/dav'

parser = argparse.ArgumentParser()
parser.add_argument('-d', '--debug', help='enable debug messages', action='store_true')

subparsers = parser.add_subparsers(required=True, dest='action')

parserDirAlbum = subparsers.add_parser(
    'dir-album', aliases=['da'], help='add all media in a folder to an album')
parserDirAlbum.add_argument(
    'remotePath', help='folder path on server, e.g. "Photos/2020/Camping trip"', type=str)

parserDeleteOldEvents = subparsers.add_parser(
    'delete-old-events', aliases=['doe'], help='find and delete old calendar events')
parserDeleteOldEvents.add_argument(
    'eventSpec', help='e.g. "calendar=personal,minimumAge=2y" to delete calendar events on the "personal" calendar older than 2 years')

parserDeleteOldTasks = subparsers.add_parser(
    'delete-old-tasks', aliases=['dot'], help='find and delete old tasks')
parserDeleteOldTasks.add_argument(
    'taskSpec', help='e.g. "list=tasks,minimumAge=2y" deletes tasks from the "tasks" lists older than 2 years')

parserInternalLink = subparsers.add_parser(
    'internal-link', aliases=['i'], help='get server-side permalink for a sync\'d file')
_argPi = parserInternalLink.add_argument(
    'localPath', help='local absolute or relative path to a sync\'d file', type=pathlib.Path)

parserLock = subparsers.add_parser(
    'lock', aliases=['l'], help='lock a file')
_argL = parserLock.add_argument(
    'localPath', help='local absolute or relative path to a sync\'d file', type=pathlib.Path)

parserUnlock = subparsers.add_parser(
    'unlock', aliases=['u'], help='unlock a file')
_argU = parserUnlock.add_argument(
    'localPath', help='local absolute or relative path to a sync\'d file', type=pathlib.Path)

try:
    import argcomplete
    _argPi.completer = argcomplete.completers.FilesCompleter
    _argL.completer = argcomplete.completers.FilesCompleter
    _argU.completer = argcomplete.completers.FilesCompleter
    argcomplete.autocomplete(parser)
except ImportError:
    pass

args = parser.parse_args()

defaultConfigLocation = os.path.expanduser('~/.config/ow/ow.ini')

if os.path.exists(defaultConfigLocation):
    config = configparser.ConfigParser()
    config.read(defaultConfigLocation)
else:
    print(f'‚õî Config not found. Please create {defaultConfigLocation} based on the example in the Readme', file=sys.stderr)
    sys.exit(1)

if not config['server']['baseUrl'].startswith('https'):
    print('üö® server baseUrl must start with https', file=sys.stderr)
    sys.exit(1)

def debug(msg):
    if args.debug:
        print(msg, file=sys.stderr)

debug(f'üëü action is {args.action}')

_auth = (config['server']['username'], config['server']['password'])

def getFilesUrl(path):
    global config, nextcloudWebdavRoot

    _filesUrl = '/'.join([config['server']['baseUrl'], nextcloudWebdavRoot, 'files', config['server']['username'], path])
    debug(f'üíª WebDAV files URL is {_filesUrl}')
    return _filesUrl

def getAlbumUrl(albumName):
    global config, nextcloudWebdavRoot
    safeAlbumName = urllib.parse.quote(albumName)
    _albumUrl = '/'.join([config['server']['baseUrl'], nextcloudWebdavRoot, 'photos', config['server']['username'], 'albums', safeAlbumName])
    debug(f'üíª WebDAV album URL is {_albumUrl}')
    return _albumUrl

def captureXmlResponse(text):
    caller = inspect.stack()[1][3]
    f = tempfile.NamedTemporaryFile(mode='w', prefix=caller+'_', delete=False)
    f.write(text)
    f.close()
    prettyOutputFilename = f.name + '.xml'
    subprocess.run(['/usr/bin/xmllint', '--format', '--output', prettyOutputFilename, f.name])
    return prettyOutputFilename

def isCollectionOrExit(filesUrl):
    global _auth, args
    debug('üèÉ fetch internal file ID...')

    _propfindBody = '''<?xml version="1.0" encoding="UTF-8"?>
    <d:propfind xmlns:d="DAV:" xmlns:oc="http://owncloud.org/ns">
      <d:prop>
        <oc:fileid />
        <d:getcontenttype />
        <d:resourcetype />
      </d:prop>
    </d:propfind>'''

    headers = {'Depth': '0'}
    try:
        response = requests.request('PROPFIND', filesUrl, auth=_auth, data=_propfindBody, headers=headers)
    except requests.RequestException as e:
        print('‚õî PROPFIND request failed: {}'.format(e), file=sys.stderr)
        sys.exit(1)

    # response status code must be between 200 and 400 to continue
    # use overloaded __bool__() to check this
    if not response:
        print(f'‚õî HTTP response code {response.status_code}. Response text: {response.text}', file=sys.stderr)
        sys.exit(1)

    if args.debug:
        prettyOutputFilename = captureXmlResponse(response.text)
        debug(f'üìù HTTP response code {response.status_code}. Response text saved in: {prettyOutputFilename}')

    root = cET.fromstring(response.text)
    dirobjs = root.findall('.//{DAV:}resourcetype/{DAV:}collection')

    if len(dirobjs) != 1:
        print('‚õî path is not a directory. HTTP response code {}. Response text: {}'.format(response.status_code, response.text), file=sys.stderr)
        sys.exit(1)

def getMedia(filesUrl):
    global config, _auth, args
    debug('üèÉ find media in given folder...')

    _propfindBody = '''<?xml version="1.0" encoding="UTF-8"?>
    <d:propfind xmlns:d="DAV:" xmlns:oc="http://owncloud.org/ns">
      <d:prop>
        <oc:fileid />
        <d:getcontenttype />
        <d:resourcetype />
      </d:prop>
    </d:propfind>'''

    try:
        response = requests.request('PROPFIND', filesUrl, auth=_auth, data=_propfindBody)
    except requests.RequestException as e:
        print('‚õî PROPFIND request failed: {}'.format(e), file=sys.stderr)
        sys.exit(1)

    # response status code must be between 200 and 400 to continue
    # use overloaded __bool__() to check this
    if not response:
        print(f'‚õî HTTP response code {response.status_code}. Response text: {response.text}', file=sys.stderr)
        sys.exit(1)

    if args.debug:
        prettyOutputFilename = captureXmlResponse(response.text)
        debug(f'üìù HTTP response code {response.status_code}. Response text saved in: {prettyOutputFilename}')

    media = []
    root = cET.fromstring(response.text)
    for r in root.findall('.//{DAV:}response'):
        contentType = r.find('.//{DAV:}getcontenttype').text
        if contentType:
            if contentType.startswith('image') or contentType.startswith('video'):
                # the "d:href" element has a path, like "/remote.php/dav/files/adam/tmp/2023-08-07%20test/test2.png"
                media.append(config['server']['baseUrl'] + r.find('.//{DAV:}href').text)

    return media

def createAlbum(albumName):
    global _auth
    print(f'üèÉ create album {albumName}...')

    albumUrl = getAlbumUrl(albumName)

    try:
        response = requests.request('MKCOL', albumUrl, auth=_auth)
    except requests.RequestException as e:
        print('‚õî MKCOL request failed: {}'.format(e), file=sys.stderr)
        sys.exit(1)

    # response status code must be between 200 and 400 to continue
    # use overloaded __bool__() to check this
    if not response:
        print(f'‚õî HTTP response code {response.status_code}. Response text: {response.text}', file=sys.stderr)
        sys.exit(1)

    debug(f'üìù HTTP response code {response.status_code}. Response text: {response.text}')

    return albumUrl

def populateAlbum(cleanedAlbumName, albumUrl, mediaUrls):
    global _auth, args
    debug('üèÉ populate new album...')

    for mediaUrl in mediaUrls:
        mediaFilename = os.path.basename(mediaUrl)
        print(f'üì∞ add {mediaFilename} to {cleanedAlbumName}')
        headers = {'Destination': '/'.join([albumUrl, mediaFilename])}
        try:
            response = requests.request('COPY', mediaUrl, auth=_auth, headers=headers)
        except requests.RequestException as e:
            print('‚õî COPY request failed: {}'.format(e), file=sys.stderr)
            sys.exit(1)

        # response status code must be between 200 and 400 to continue
        # use overloaded __bool__() to check this
        if not response:
            print(f'‚õî HTTP response code {response.status_code}. Response text: {response.text}', file=sys.stderr)
            sys.exit(1)

def cleanAlbumName(rawAlbumName):
    debug(f'üíª raw album name is {rawAlbumName}')
    noTrailingSlash = re.sub(r'/$', '', rawAlbumName)
    debug(f'üíª without trailing slash: {noTrailingSlash}')
    based = os.path.basename(noTrailingSlash)
    debug(f'üíª basenamed: {based}')
    # This step is arbitrary, originally based on author preferences.
    # Might be better to accept a new option argument to explicitly set the album name.
    # e.g. `ow dir-album -a 'Camping trip' 'Photos/2020-04-01 Camping trip'`
    clean = re.sub(r'^\d{4}-\d{2}-\d{2}\s+-?\s*', '', based)
    debug(f'üíª clean album name is {clean}')
    if not clean:
        print(f'‚õî invalid album name: {clean}', file=sys.stderr)
        sys.exit(1)
    return clean

def normalizeLocalPath(localPath):
    global config
    if not os.path.exists(localPath):
        print('‚õî Error: path does not exist', file=sys.stderr)
        sys.exit(1)

    realpath = os.path.realpath(localPath)
    debug(f'üìÅ absolute path is {realpath}')

    # remove localSyncFolder from realpath
    relativePathOnly = re.sub(config['local']['syncFolder'], '', realpath)[1:]
    debug(f'üìë relative path is {relativePathOnly}')

    return relativePathOnly

def getFileId(fileurl):
    global _auth
    debug('üèÉ fetch internal file ID...')

    _propfindBody = '''<?xml version="1.0" encoding="UTF-8"?>
    <d:propfind xmlns:d="DAV:">
      <d:prop xmlns:oc="http://owncloud.org/ns">
        <oc:fileid/>
      </d:prop>
    </d:propfind>'''

    try:
        response = requests.request('PROPFIND', fileurl, auth=_auth, data=_propfindBody)
    except requests.RequestException as e:
        print(f'‚õî PROPFIND request failed: {e}', file=sys.stderr)
        sys.exit(1)

    # response status code must be between 200 and 400 to continue
    # use overloaded __bool__() to check this
    if not response:
        print(f'‚õî HTTP response code {response.status_code}. Response text: {response.text}', file=sys.stderr)
        sys.exit(1)

    debug(f'üìù HTTP response code {response.status_code}. Response text: {response.text}')

    root = cET.fromstring(response.text)
    fileId = root.findtext('.//{http://owncloud.org/ns}fileid')
    debug(f'üóÉÔ∏è fileId is {fileId}')

    if fileId is None:
        print(f'‚õî HTTP response code {response.status_code}. Response text: {response.text}', file=sys.stderr)
        sys.exit(1)

    return fileId

def lockOrUnlock(action, fileurl):
    global _auth

    if action == 'lock':
        method = 'LOCK'
    elif action == 'unlock':
        method = 'UNLOCK'
    else:
        print(f'‚õî internal error. action={action}', file=sys.stderr)

    headers = {'X-User-Lock': '1'}
    debug(f'üìÑ request: {method} {fileurl}')
    debug(f'üìé headers: {headers}')

    try:
        response = requests.request(method, fileurl, auth=_auth, headers=headers)
    except requests.RequestException as e:
        print(f'‚õî request failed: {e}', file=sys.stderr)
        sys.exit(1)

    # response status code must be between 200 and 400 to continue
    # use overloaded __bool__() to check this
    if not response:
        print(f'‚õî {action} failed. Is the Temporary files lock app installed? If attempting to lock, is it already locked by someone/something else? If attempting to unlock, is the path actually locked, and are you permitted to unlock it?', file=sys.stderr)
        print(f'üìÑ HTTP request was {method} {fileurl}', file=sys.stderr)
        print(f'üì® HTTP response code {response.status_code}. Response text: {response.text}', file=sys.stderr)
        sys.exit(1)

    debug(f'üìù HTTP response code {response.status_code}. Response text: {response.text}')

def datetimeFromAgeInYears(minimumAge):
    y = int(minimumAge.split('y')[0])
    offset = timedelta(days=365 * y)
    offsetTime = datetime.now(timezone.utc) - offset
    return offsetTime

def buildTimeRange(minimumAge):
    startTime = '20100101T000000Z'
    offsetTime = datetimeFromAgeInYears(minimumAge)
    endTime = offsetTime.strftime("%Y%m%dT%H%M%SZ")
    return (startTime, endTime)

def findOldEvents(calendar, minimumAge):
    global config, _auth, args
    debug(f'üîç search for events in calendar {calendar} older than {minimumAge}...')

    (startTime,endTime) = buildTimeRange(minimumAge)

    _requestBody = f'''<?xml version="1.0"?>
<x1:calendar-query xmlns:x1="urn:ietf:params:xml:ns:caldav">
  <x0:prop xmlns:x0="DAV:">
    <x1:calendar-data/>
  </x0:prop>
  <x1:filter>
    <x1:comp-filter name="VCALENDAR">
      <x1:comp-filter name="VEVENT">
        <x1:time-range start="{startTime}" end="{endTime}"/>
      </x1:comp-filter>
    </x1:comp-filter>
  </x1:filter>
</x1:calendar-query>'''

    url = '/'.join([config['server']['baseUrl'], nextcloudWebdavRoot, 'calendars', config['server']['username'], calendar])

    method = 'REPORT'
    headers = {'Depth': '1'}
    try:
        response = requests.request(method, url, auth=_auth, data=_requestBody, headers=headers)
    except requests.RequestException as e:
        print(f'‚õî {method} request failed: {e}', file=sys.stderr)
        sys.exit(1)

    # response status code must be between 200 and 400 to continue
    # use overloaded __bool__() to check this
    if not response:
        print(f'‚õî HTTP response code {response.status_code}. Response text: {response.text}', file=sys.stderr)
        sys.exit(1)

    if args.debug:
        prettyOutputFilename = captureXmlResponse(response.text)
        debug(f'üìù HTTP response code {response.status_code}. Response text saved in: {prettyOutputFilename}')

    eventDavPaths = []

    root = cET.fromstring(response.text)
    for href in root.findall('.//{DAV:}href'):
        eventDavPaths.append(href.text)

    return eventDavPaths

def deleteDavResource(path):
    url = '/'.join([config['server']['baseUrl'], path])
    try:
        response = requests.request('DELETE', url, auth=_auth)
    except requests.RequestException as e:
        print('‚õî DELETE request failed: {}'.format(e), file=sys.stderr)
        sys.exit(1)

def deleteEvents(eventDavPaths):
    global config, _auth

    for eventDavPath in eventDavPaths:
        debug(f'üèÉ delete event {eventDavPath}...')
        deleteDavResource(eventDavPath)

def findCompletedTasks(tlist):
    global config, _auth, args
    debug(f'üîç search for completed tasks in list {tlist}...')

    # this doesn't seem to work like a proper AND query, so I have to get all
    # completed tasks, then filter them by date later
    _requestBody = f'''<?xml version="1.0"?>
<x1:calendar-query xmlns:x1="urn:ietf:params:xml:ns:caldav">
  <x0:prop xmlns:x0="DAV:">
    <x1:calendar-data/>
  </x0:prop>
  <x1:filter>
    <x1:comp-filter name="VCALENDAR">
      <x1:comp-filter name="VTODO">
        <x1:prop-filter name="STATUS">
          <x1:text-match collation="i;ascii-casemap">COMPLETED</x1:text-match>
        </x1:prop-filter>
      </x1:comp-filter>
    </x1:comp-filter>
  </x1:filter>
</x1:calendar-query>'''

    url = '/'.join([config['server']['baseUrl'], nextcloudWebdavRoot, 'calendars', config['server']['username'], tlist])

    method = 'REPORT'
    headers = {'Depth': '1'}
    try:
        response = requests.request(method, url, auth=_auth, data=_requestBody, headers=headers)
    except requests.RequestException as e:
        print(f'‚õî {method} request failed: {e}', file=sys.stderr)
        sys.exit(1)

    # response status code must be between 200 and 400 to continue
    # use overloaded __bool__() to check this
    if not response:
        print(f'‚õî HTTP response code {response.status_code}. Response text: {response.text}', file=sys.stderr)
        sys.exit(1)

    if args.debug:
        prettyOutputFilename = captureXmlResponse(response.text)
        debug(f'üìù HTTP response code {response.status_code}. Response text saved in: {prettyOutputFilename}')

    taskDavPaths = []

    root = cET.fromstring(response.text)
    for href in root.findall('.//{DAV:}href'):
        taskDavPaths.append(href.text)

    return taskDavPaths

def dateStringToObject(dateStr):
    # force UTC always, we're dealing with year comparsions so 1 day or less doesn't matter
    if not dateStr.endswith('Z'):
        dateStr += 'Z'
    return parse(dateStr)

def getTask(taskPath):
    try:
        url = '/'.join([config['server']['baseUrl'], taskPath])
        response = requests.get(url, auth=_auth)
    except requests.RequestException as e:
        print(f'‚õî GET request failed: {e}', file=sys.stderr)
        sys.exit(1)
    t = {}
    t['_dav_path'] = url
    for line in response.text.split('\r\n'):
        if re.match(r'^BEGIN:VTODO$', line):
            t['type'] = 'task'
        elif m := re.match(r'^STATUS:([A-Z]+)$', line):
            t['status'] = m[1] # e.g. COMPLETED
        elif m := re.match(r'^COMPLETED:([0-9]{8}T[0-9]{6}Z?)$', line):
            rawDate = m[1] # e.g. 20230623T220922Z
            t['completed'] = dateStringToObject(rawDate)
    return t

def isOlderThan(task, minimumAge):
    thisDate = task['completed']
    minDate = datetimeFromAgeInYears(minimumAge)
    # smaller is older
    return thisDate < minDate

def isValidTask(task, minimumAge):
    if task['type'] != 'task':
        print('‚õî invalid type: ' + task['type'])
        sys.exit(1)

    if task['status'] != 'COMPLETED':
        print('‚õî invalid status: ' + task['status'])
        sys.exit(1)

    if 'completed' not in task:
        print(f'‚õî {task} missing completed date')
        sys.exit(1)

def filterTasks(tasks, minimumAge):
    debug(f'üîç filter tasks by minimumAge={minimumAge}...')
    (startTime,endTime) = buildTimeRange(minimumAge)
    for taskPath in tasks:
        debug(f'‚öóÔ∏è checking task: {taskPath}')
        t = getTask(taskPath)
        isValidTask(t, minimumAge)
        if isOlderThan(t, minimumAge):
            debug(f'üçë ripe. completed at: ' + str(t['completed']))
        else:
            debug(f'üë∂ too young, completed at: ' + str(t['completed']))
            continue
    return tasks

def deleteTasks(taskDavPaths):
    global config, _auth

    for taskDavPath in taskDavPaths:
        debug(f'üèÉ delete task {taskDavPath}...')
        # FIXME - remove
        debug('üöß abort -- under construction')
        break
        #deleteDavResource(taskDavPath)

if args.action in ['da','dir-album']:
    debug('üèÉ make album from directory...')
    ncRelativeAlbumPath = args.remotePath
    folderWithPhotosUrl = getFilesUrl(ncRelativeAlbumPath)

    # Confirm we got a path to a collection (folder). If not, this call will
    # exit early. Still might not be a valid photo album, though.
    isCollectionOrExit(folderWithPhotosUrl)

    cleanedAlbumName = cleanAlbumName(ncRelativeAlbumPath)

    debug(f'üìÅ album name will be: {cleanedAlbumName}...')
    albumUrl = createAlbum(cleanedAlbumName)

    debug(f'üìÅ walk collection: {ncRelativeAlbumPath}...')
    mediaUrls = getMedia(folderWithPhotosUrl)

    populateAlbum(cleanedAlbumName, albumUrl, mediaUrls)

    debug('üñºÔ∏è success!')

if args.action in ['doe','delete-old-events']:
    debug('üèÉ delete old events...')
    # parse "old events" spec
    (arg1, arg2) = args.eventSpec.split(',')
    calendar = arg1.split('=')[1]
    minimumAge = arg2.split('=')[1]
    # find events
    eventDavPaths = findOldEvents(calendar, minimumAge)
    # delete events
    deleteEvents(eventDavPaths)
    debug('üóëÔ∏è success!')

if args.action in ['dot','delete-old-tasks']:
    debug('üèÉ delete old tasks...')
    # parse "old tasks" spec
    (arg1, arg2) = args.taskSpec.split(',')
    tlist = arg1.split('=')[1]
    minimumAge = arg2.split('=')[1]
    # find tasks
    completed = findCompletedTasks(tlist)
    taskDavPaths = filterTasks(completed, minimumAge)
    # delete tasks
    deleteTasks(taskDavPaths)
    debug('üóëÔ∏è success!')

if args.action in ['i','internal-link']:
    debug('üèÉ get internal link...')
    fileId = getFileId(getFilesUrl(normalizeLocalPath(args.localPath)))
    baseUrl = config['server']['baseUrl']
    print(f'{baseUrl}/f/{fileId}')

if args.action in ['l','lock']:
    debug(f'üèÉ lock...')
    lockOrUnlock('lock', getFilesUrl(normalizeLocalPath(args.localPath)))
    debug('üîí success!')

if args.action in ['u','unlock']:
    debug('üèÉ unlock...')
    lockOrUnlock('unlock', getFilesUrl(normalizeLocalPath(args.localPath)))
    debug('üîì success!')
