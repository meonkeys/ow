#!/usr/bin/python3

# ow - Nextcloud command-line client - main code
# Copyright (C) 2023  Adam Monsen
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import configparser
import os
import re
import requests
import sys
import subprocess
import tempfile
import xml.etree.cElementTree as cET
import urllib

nextcloudWebdavRoot = 'remote.php/dav'

parser = argparse.ArgumentParser()
parser.add_argument('-d', '--debug', help='enable debug messages', action='store_true')
parser.add_argument('action', help='action to perform', choices=['da','dir-album','i','internal-link','l','lock','u','unlock'])
parser.add_argument('target', help='target to operate on. For dir-album, this is a remote path. For internal-link, lock, and unlock, this is a local path.')
args = parser.parse_args()

defaultConfigLocation = os.path.expanduser('~/.config/ow/ow.ini')
config = None

if os.path.exists(defaultConfigLocation):
    config = configparser.ConfigParser()
    config.read(defaultConfigLocation)
else:
    print(f'‚õî Config not found. Please create {defaultConfigLocation} based on owconfig.example.', file=sys.stderr)
    sys.exit(1)

def debug(msg):
    if args.debug:
        print(msg, file=sys.stderr)

debug(f'üëü action is {args.action}')

_auth = (config['server']['username'], config['server']['password'])

def getFilesUrl(path):
    global config, nextcloudWebdavRoot

    _filesUrl = '/'.join([config['server']['baseUrl'], nextcloudWebdavRoot, 'files', config['server']['username'], path])
    debug(f'üíª WebDAV files URL is {_filesUrl}')
    return _filesUrl

def getAlbumUrl(albumName):
    global config, nextcloudWebdavRoot
    safeAlbumName = urllib.parse.quote(albumName)
    _albumUrl = '/'.join([config['server']['baseUrl'], nextcloudWebdavRoot, 'photos', config['server']['username'], 'albums', safeAlbumName])
    debug(f'üíª WebDAV album URL is {_albumUrl}')
    return _albumUrl

def captureXmlResponse(text):
    f = tempfile.NamedTemporaryFile(mode='w', prefix='dir-album_', delete=False)
    f.write(text)
    f.close()
    prettyOutputFilename = f.name + '.xml'
    subprocess.run(['/usr/bin/xmllint', '--format', '--output', prettyOutputFilename, f.name])
    return prettyOutputFilename

def isCollectionOrExit(filesUrl):
    global _auth, args
    debug('üèÉ fetch internal file ID...')

    _propfindBody = '''<?xml version="1.0" encoding="UTF-8"?>
    <d:propfind xmlns:d="DAV:" xmlns:oc="http://owncloud.org/ns">
      <d:prop>
        <oc:fileid />
        <d:getcontenttype />
        <d:resourcetype />
      </d:prop>
    </d:propfind>'''

    headers = {'Depth': '0'}
    try:
        response = requests.request('PROPFIND', filesUrl, auth=_auth, data=_propfindBody, headers=headers)
    except requests.RequestException as e:
        print('‚õî PROPFIND request failed: {}'.format(e), file=sys.stderr)
        sys.exit(1)

    # response status code must be between 200 and 400 to continue
    # use overloaded __bool__() to check this
    if not response:
        print(f'‚õî HTTP response code {response.status_code}. Response text: {response.text}', file=sys.stderr)
        sys.exit(1)

    if args.debug:
        prettyOutputFilename = captureXmlResponse(response.text)
        debug(f'üìù HTTP response code {response.status_code}. Response text saved in: {prettyOutputFilename}')

    root = cET.fromstring(response.text)
    dirobjs = root.findall('.//{DAV:}resourcetype/{DAV:}collection')

    if len(dirobjs) != 1:
        print('‚õî path is not a directory. HTTP response code {}. Response text: {}'.format(response.status_code, response.text), file=sys.stderr)
        sys.exit(1)

def getMedia(filesUrl):
    global config, _auth, args
    debug('üèÉ find media in given folder...')

    _propfindBody = '''<?xml version="1.0" encoding="UTF-8"?>
    <d:propfind xmlns:d="DAV:" xmlns:oc="http://owncloud.org/ns">
      <d:prop>
        <oc:fileid />
        <d:getcontenttype />
        <d:resourcetype />
      </d:prop>
    </d:propfind>'''

    try:
        response = requests.request('PROPFIND', filesUrl, auth=_auth, data=_propfindBody)
    except requests.RequestException as e:
        print('‚õî PROPFIND request failed: {}'.format(e), file=sys.stderr)
        sys.exit(1)

    # response status code must be between 200 and 400 to continue
    # use overloaded __bool__() to check this
    if not response:
        print(f'‚õî HTTP response code {response.status_code}. Response text: {response.text}', file=sys.stderr)
        sys.exit(1)

    if args.debug:
        prettyOutputFilename = captureXmlResponse(response.text)
        debug(f'üìù HTTP response code {response.status_code}. Response text saved in: {prettyOutputFilename}')

    media = []
    root = cET.fromstring(response.text)
    for r in root.findall('.//{DAV:}response'):
        contentType = r.find('.//{DAV:}getcontenttype').text
        if contentType:
            if contentType.startswith('image') or contentType.startswith('video'):
                # the "d:href" element has a path, like "/remote.php/dav/files/adam/tmp/2023-08-07%20test/test2.png"
                media.append(config['server']['baseUrl'] + r.find('.//{DAV:}href').text)

    return media

def createAlbum(albumName):
    global _auth
    print(f'üèÉ create album {albumName}...')

    albumUrl = getAlbumUrl(albumName)

    try:
        response = requests.request('MKCOL', albumUrl, auth=_auth)
    except requests.RequestException as e:
        print('‚õî MKCOL request failed: {}'.format(e), file=sys.stderr)
        sys.exit(1)

    # response status code must be between 200 and 400 to continue
    # use overloaded __bool__() to check this
    if not response:
        print(f'‚õî HTTP response code {response.status_code}. Response text: {response.text}', file=sys.stderr)
        sys.exit(1)

    debug(f'üìù HTTP response code {response.status_code}. Response text: {response.text}')

    return albumUrl

def populateAlbum(cleanedAlbumName, albumUrl, mediaUrls):
    global _auth, args
    debug('üèÉ populate new album...')

    for mediaUrl in mediaUrls:
        mediaFilename = os.path.basename(mediaUrl)
        print(f'üì∞ add {mediaFilename} to {cleanedAlbumName}')
        headers = {'Destination': '/'.join([albumUrl, mediaFilename])}
        try:
            response = requests.request('COPY', mediaUrl, auth=_auth, headers=headers)
        except requests.RequestException as e:
            print('‚õî COPY request failed: {}'.format(e), file=sys.stderr)
            sys.exit(1)

        # response status code must be between 200 and 400 to continue
        # use overloaded __bool__() to check this
        if not response:
            print(f'‚õî HTTP response code {response.status_code}. Response text: {response.text}', file=sys.stderr)
            sys.exit(1)

def cleanAlbumName(rawAlbumName):
    debug(f'üíª raw album name is {rawAlbumName}')
    noTrailingSlash = re.sub(r'/$', '', rawAlbumName)
    debug(f'üíª without trailing slash: {noTrailingSlash}')
    based = os.path.basename(noTrailingSlash)
    debug(f'üíª basenamed: {based}')
    clean = re.sub(r'^\d{4}-\d{2}-\d{2}\s+', '', based)
    debug(f'üíª clean album name is {clean}')
    if not clean:
        print(f'‚õî invalid album name: {clean}', file=sys.stderr)
        sys.exit(1)
    return clean

def normalizeLocalPath(localPath):
    global config
    if not os.path.exists(localPath):
        print('‚õî Error: path does not exist', file=sys.stderr)
        sys.exit(1)

    realpath = os.path.realpath(localPath)
    debug(f'üìÅ absolute path is {realpath}')

    # remove localSyncFolder from realpath
    relativePathOnly = re.sub(config['local']['syncFolder'], '', realpath)[1:]
    debug(f'üóÇÔ∏è relative path is {relativePathOnly}')

    return relativePathOnly

def getFileId(fileurl):
    global _auth
    debug('üèÉ fetch internal file ID...')

    _propfindBody = '''<?xml version="1.0" encoding="UTF-8"?>
    <d:propfind xmlns:d="DAV:">
      <d:prop xmlns:oc="http://owncloud.org/ns">
        <oc:fileid/>
      </d:prop>
    </d:propfind>'''

    try:
        response = requests.request('PROPFIND', fileurl, auth=_auth, data=_propfindBody)
    except requests.RequestException as e:
        print(f'‚õî PROPFIND request failed: {e}', file=sys.stderr)
        sys.exit(1)

    # response status code must be between 200 and 400 to continue
    # use overloaded __bool__() to check this
    if not response:
        print(f'‚õî HTTP response code {response.status_code}. Response text: {response.text}', file=sys.stderr)
        sys.exit(1)

    debug(f'üìù HTTP response code {response.status_code}. Response text: {response.text}')

    root = cET.fromstring(response.text)
    fileId = root.findtext('.//{http://owncloud.org/ns}fileid')
    debug(f'üóÉÔ∏è fileId is {fileId}')

    if fileId is None:
        print(f'‚õî HTTP response code {response.status_code}. Response text: {response.text}', file=sys.stderr)
        sys.exit(1)

    return fileId

def lockOrUnlock(action, fileurl):
    global _auth

    if action == 'lock':
        method = 'LOCK'
    elif action == 'unlock':
        method = 'UNLOCK'
    else:
        print(f'‚õî internal error. action={action}', file=sys.stderr)

    headers = {'X-User-Lock': '1'}
    debug(f'üìÑ request: {method} {fileurl}')
    debug(f'üìé headers: {headers}')

    try:
        response = requests.request(method, fileurl, auth=_auth, headers=headers)
    except requests.RequestException as e:
        print(f'‚õî request failed: {e}', file=sys.stderr)
        sys.exit(1)

    # response status code must be between 200 and 400 to continue
    # use overloaded __bool__() to check this
    if not response:
        print(f'‚õî {action} failed. Is the Temporary files lock app installed? If attempting to lock, is it already locked by someone/something else? If attempting to unlock, is the path actually locked?', file=sys.stderr)
        print(f'üìÑ HTTP request was {method} {fileurl}', file=sys.stderr)
        print(f'üì® HTTP response code {response.status_code}. Response text: {response.text}', file=sys.stderr)
        sys.exit(1)

    debug(f'üìù HTTP response code {response.status_code}. Response text: {response.text}')

if args.action in ['da','dir-album']:
    debug('üèÉ make album from directory...')
    ncRelativeAlbumPath = args.target
    folderWithPhotosUrl = getFilesUrl(ncRelativeAlbumPath)

    # Confirm we got a path to a collection (folder). If not, this call will
    # exit early. Still might not be a valid photo album, though.
    isCollectionOrExit(folderWithPhotosUrl)

    cleanedAlbumName = cleanAlbumName(ncRelativeAlbumPath)

    debug(f'üìÅ album name will be: {cleanedAlbumName}...')
    albumUrl = createAlbum(cleanedAlbumName)

    debug(f'üìÅ walk collection: {ncRelativeAlbumPath}...')
    mediaUrls = getMedia(folderWithPhotosUrl)

    populateAlbum(cleanedAlbumName, albumUrl, mediaUrls)

    debug('üîì success!')

if args.action in ['i','internal-link']:
    debug('üèÉ get internal link...')
    fileId = getFileId(getFilesUrl(normalizeLocalPath(args.target)))
    baseUrl = config['server']['baseUrl']
    print(f'{baseUrl}/f/{fileId}')

if args.action in ['l','lock']:
    debug(f'üèÉ lock...')
    lockOrUnlock('lock', getFilesUrl(normalizeLocalPath(args.target)))
    debug('üîí success!')

if args.action in ['u','unlock']:
    debug('üèÉ unlock...')
    lockOrUnlock('unlock', getFilesUrl(normalizeLocalPath(args.target)))
    debug('üîì success!')
